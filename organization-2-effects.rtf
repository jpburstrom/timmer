{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 EnvyCodeR;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs24 \cf2 \
\cf3 // play back a soundfile with different effects\cf2 \
\cf3 // dewdrop_world, http://www.dewdrop-world.net\cf2 \
\cf3 // code is released under the LGPL, http://creativecommons.org/licenses/LGPL/2.1/\cf2 \
\
\cf3 // on init: load soundfile, prepare mixerchannel and effect synthdefs\cf2 \
\cf3 // 	on play: start the buffer playback synth\cf2 \
\cf3 // 	on stop: release the buffer playback synth\cf2 \
\cf3 // on free: release the buffer and mixerchannel\cf2 \
\
\cf3 /**** basic template, don't run this!\
PR(\\abstractProcess).v.clone(\{\
	~prep = \{\
	\};\
	\
	~asPattern = \{\
	\};\
	\
	~stopCleanup = \{\
	\};\
	\
	~freeCleanup = \{\
	\};\
\}) => PR(\\bufPlayer);\
****/\cf2 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 PR\cf2 (\cf5 \\abstractProcess\cf2 ).v.clone(\{\
	~event = (eventKey: \cf5 \\singleSynthPlayer\cf2 );\
	~soundfile = \cf6 "sounds/a11wlk01.wav"\cf2 ;\
	\
		\cf3 // these will be compiled into synthdefs in ~prep\cf2 \
	~effects = [\
		(name: \cf5 \\ringmod1\cf2 , func: \{ \cf4 |sig, freq|\cf2 \
			\cf4 SinOsc\cf2 .ar(freq, 0, sig)\
		\}, args: \{ [\cf5 \\freq\cf2 , exprand(100, 2000)] \}),\
\
		(name: \cf5 \\ringmod2\cf2 , func: \{ \cf4 |sig, freq, lofreq, hifreq|\cf2 \
			\cf4 SinOsc\cf2 .ar(\cf4 LFNoise1\cf2 .kr(freq).range(lofreq, hifreq), 0, sig)\
		\}, args: \{ [\cf5 \\freq\cf2 , rrand(0.1, 1.6), \cf5 \\lofreq\cf2 , exprand(100, 2000),\
			\cf5 \\hifreq\cf2 , exprand(100, 2000)] \}),\
\
		(name: \cf5 \\comb1\cf2 , func: \{ \cf4 |sig, delay, dur|\cf2 \
			\cf4 CombN\cf2 .ar(sig, delay + 0.01, delay, dur)\
		\}, args: \{ [\cf5 \\delay\cf2 , exprand(50, 500).reciprocal, \cf5 \\dur\cf2 , rrand(0.05, 1.0)] \}),\
\
		(name: \cf5 \\comb2\cf2 , func: \{ \cf4 |sig, freq, lodelay, hidelay, dur|\cf2 \
			\cf4 CombL\cf2 .ar(sig, hidelay + 0.01, \cf4 LFNoise1\cf2 .kr(freq).exprange(lodelay, hidelay), dur)\
		\}, args: \{ \cf4 var\cf2  d1 = exprand(50, 500).reciprocal, d2 = exprand(50, 500).reciprocal;\
			[\cf5 \\freq\cf2 , rrand(0.2, 14.0), \cf5 \\lodelay\cf2 , min(d1, d2), \cf5 \\hidelay\cf2 , max(d1, d2),\
			\cf5 \\dur\cf2 , rrand(0.05, 1.0)] \}),\
\
		(name: \cf5 \\echo\cf2 , func: \{ \cf4 |sig, delay, dur|\cf2 \
			\cf4 CombN\cf2 .ar(sig, delay + 0.01, delay, dur)\
		\}, args: \{ [\cf5 \\delay\cf2 , rrand(0.4, 1.0), \cf5 \\dur\cf2 , rrand(4.0, 12.0)] \})\
	];\
	\
	~prep = \{\
		~buffer = \cf4 Buffer\cf2 .read(s, ~soundfile);\
		\cf4 SynthDef\cf2 (\cf5 \\bufPlayer1\cf2 , \{ \cf4 |outbus, bufnum, gate = 1|\cf2 \
			\cf4 var\cf2 	basefreq = \cf4 BufDur\cf2 .ir(bufnum).reciprocal * 0.94,\
				trig = \cf4 Impulse\cf2 .kr(basefreq + \cf4 LFNoise1\cf2 .kr(1, basefreq * 0.5, basefreq * 0.9)),\
				env = \cf4 EnvGen\cf2 .kr(\cf4 Env\cf2 (#[1, 1, 0], #[1, 0.2], -4, 1), gate, doneAction:2),\
				sig = \cf4 PlayBuf\cf2 .ar(1, bufnum, \cf4 BufRateScale\cf2 .ir(bufnum), trig,\
					\cf4 TRand\cf2 .kr(0, \cf4 BufFrames\cf2 .ir(bufnum) * 0.5, trig));\
			\cf4 Out\cf2 .ar(outbus, \cf4 Pan2\cf2 .ar(sig * env, \cf4 LFNoise1\cf2 .kr(1)))\
		\}).send(\cf4 Server\cf2 .default);\
		~bufplayer = \cf5 \\bufPlayer1\cf2 ;\
		\
			\cf3 // build effects by wrapping effect function in a fade in/out envelope\cf2 \
			\cf3 // also include random panning\cf2 \
		~effects.do(\{ \cf4 |fxdef|\cf2 \
			\cf4 SynthDef\cf2 (fxdef.name, \{ \cf4 |gate = 1, fadetime = 4, holdtime = 4, outbus|\cf2 \
				\cf4 var\cf2 	sig = \cf4 In\cf2 .ar(outbus, 2),\
					wetenv = \cf4 EnvGen\cf2 .kr(\cf4 Env\cf2 (#[0, 1, 1, 0], [fadetime, holdtime, fadetime],\
						\cf5 \\lin\cf2 ), gate, doneAction:2),\
					wetsig;\
				wetsig = \cf4 SynthDef\cf2 .wrap(fxdef[\cf5 \\func\cf2 ], \cf4 nil\cf2 , [sig]);\
				sig = \cf4 XFade2\cf2 .ar(sig, \cf4 Limiter\cf2 .ar(wetsig, 0.9), wetenv.madd(2, -1));\
				\cf4 ReplaceOut\cf2 .ar(outbus, sig);\
			\}).send(\cf4 Server\cf2 .default);\
		\});\
		\
		~fade = \cf4 Pwhite\cf2 (2.0, 8.0, \cf4 inf\cf2 );\
		~hold = \cf4 Pwhite\cf2 (5.0, 16.0, \cf4 inf\cf2 );\
		~dfactor = \cf4 Pwhite\cf2 (0.4, 0.7, \cf4 inf\cf2 );\
		\
		~chan = \cf4 MixerChannel\cf2 (\cf5 \\bufPlayer\cf2 , inChannels:2, outChannels:2);\
	\};\
	\
		\cf3 // bufplayer synth needs to be created every time I play\cf2 \
		\cf3 // therefore reset is required every time\cf2 \
	~alwaysReset = \cf4 true\cf2 ;\
	\
	~asPattern = \{\
		\cf4 Pseq\cf2 ([\
			\cf4 Pfuncn\cf2 (\{\
				~bufsynth.isNil.if(\{  \cf3 // does my runtime resource exist?\cf2 \
					~chan.server.makeBundle(~leadTime / \cf4 thisThread\cf2 .clock.tempo, \{\
						~bufsynth = ~chan.play(~bufplayer, \
							[\cf5 \\bufnum\cf2 , ~buffer.bufnum]);\
					\});\
				\});\
				(play: 0, delta: rrand(2.0, 5.0))	\cf3 // dummy event\cf2 \
			\}, 1),\
			\cf4 Pbind\cf2 (\
				\cf5 \\chan\cf2 , ~chan,\
				\cf5 \\isFx\cf2 , \cf4 true\cf2 ,\
				\cf5 \\fxdef\cf2 , \cf4 Pfunc\cf2 (\{ ~effects.choose \}),\
				\cf5 \\instrument\cf2 , \cf4 Pfunc\cf2 (\{ \cf4 |ev|\cf2  ev[\cf5 \\fxdef\cf2 ].name \}),\
				\cf5 \\fadetime\cf2 , \cf4 BPStream\cf2 (\cf5 \\fade\cf2 ),\
				\cf5 \\holdtime\cf2 , \cf4 BPStream\cf2 (\cf5 \\hold\cf2 ),\
				\cf5 \\delta\cf2 , \cf4 Pfunc\cf2 (\{ \cf4 |ev|\cf2  (ev[\cf5 \\holdtime\cf2 ] + (ev[\cf5 \\fadetime\cf2 ] * 2)) \})\
					* \cf4 BPStream\cf2 (\cf5 \\dfactor\cf2 )\
			).collect(\{ \cf4 |ev|\cf2 \
				ev[\cf5 \\fxdef\cf2 ].args.pairsDo(\{ \cf4 |key, value|\cf2 \
					ev.put(key, value)\
				\});\
				ev\
			\});\
		], 1)\
	\};\
	\
	~stopCleanup = \{\
		~bufsynth !? \{ ~bufsynth.set(\cf5 \\gate\cf2 , 0); ~bufsynth = \cf4 nil\cf2 ; \};\
	\};\
	\
	~freeCleanup = \{\
		[~chan, ~buffer].free;\
		~effects.do(\{ \cf4 |fxdef|\cf2  fxdef.name.free \});\
	\};\
\}) => \cf4 PR\cf2 (\cf5 \\fxOverlap\cf2 );\
)\
\
\
\cf4 PR\cf2 (\cf5 \\fxOverlap\cf2 ) => \cf4 BP\cf2 (\cf5 \\test\cf2 );\
\cf4 BP\cf2 (\cf5 \\test\cf2 ).play;\
\
\cf4 Pwhite\cf2 (0.1, 0.4, \cf4 inf\cf2 ) =>.dfactor \cf4 BP\cf2 (\cf5 \\test\cf2 );\
\cf4 Pwhite\cf2 (0.4, 0.8, \cf4 inf\cf2 ) =>.dfactor \cf4 BP\cf2 (\cf5 \\test\cf2 );\
\
\cf4 BP\cf2 (\cf5 \\test\cf2 ).stop;\
\cf4 BP\cf2 (\cf5 \\test\cf2 ).free;\
\
\cf4 BP\cf2 (\cf5 \\test\cf2 ).listVars}